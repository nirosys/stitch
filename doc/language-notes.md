> NOTE: This PoC is being explored as much as developed, so
> all of the information here may be out of date as to how the
> current feature set or behaviors actually work.

# The Stitch Language
Stitch is a language designed for configuring, and altering, flow-based
programs.

## Goals
The goal for the stitch language is to provide a concise language for
defining the DAG used for retrieving, and normalizing, network device
information.

More specific goals:

   * Provide an easy to learn syntax for building data flows.
   * Provide syntax to support more flexible edge creation that
     cannot be done with the existing YAML-based configuration.
   * Provide enough flexibility to build up reusable constructs.

## Features / TODOs
List of features that we need, and what is implemented:

- [x] Variables
  - [x] Syntax Decided
  - [x] `let` statements
  - [x] Evaluation
- [ ] Primitives
  - [x] Integer
    - [x] Parse Literals
    - [x] Evaluation
  - [ ] Float
    - [ ] Parse Literals
    - [ ] Evaluation
  - [x] Bool
    - [x] Parse Literals (`true` and `false`)
    - [x] Evaluation
    - [x] `and`, `or` keywords, and `!` operator.
  - [x] String
    - [x] Parse Literals
    - [x] Evaluation
  - [x] Function
    - [x] Parse Literals
    - [x] Evaluation
  - [x] List
    - [x] Parse Literals
    - [x] Evaluation
  - [ ] Node
    - [x] Parse Literals
    - [ ] Evaluation
- [x] Function Definitions
  - [x] Syntax Decided
  - [x] Parsing, Keyword(s), etc.
  - [x] Evaluation
- [x] Function Expressions / Lambdas
  - [x] Syntax Decided
  - [x] Parsing, Keyword(s), etc.
  - [x] Evaluation
- [ ] Function Calling
  - [x] Syntax Decided
  - [ ] Named arguments
  - [x] Evaluation
- [ ] Node Implementations
  - [x] Syntax Decided
  - [ ] Mapping to Gaufre Nodes
    - [x] Build Gaufre graph for nodes.
    - [ ] Communicate node implementations via gaufre graph.
  - [x] Parsing, Keyword(s), etc
  - [ ] Named arguments
  - [x] Evaluation
- [ ] Control Flow
  - [x] `if`/`else`
    - [x] Syntax Decided
    - [x] Parsing, Keyword(s), etc
    - [x] Evaluation
  - [ ] `switch`
    - [ ] Syntax Decided
    - [ ] Parsing, Keyword(s), etc
    - [ ] Evaluation
  - [x] `foreach`
    - [x] Syntax Decided
    - [x] Parsing, Keyword(s), etc
    - [x] Evaluation
- [x] Lists (As a data type, and `->` support)
  - [x] Syntax Decided
  - [x] Parsing, Keyword(s), etc.
  - [x] Evaluation
  - [x] Operations:
    - [x] Concat Lists (`+`)
- [x] Metadata
  - [x] Syntax Decided
  - [x] Parsing, Keyword(s), etc
  - [x] Evaluation
- [x] Field Names
  - [x] Syntax Decided
  - [x] Parsing, Keyword(s), etc
  - [x] Evaluation
- [ ] Internals
  - [ ] Syntax Decided
  - [x] Parsing, Keyword(s), etc
  - [x] Evaluation
- [ ] Modifiers
  - [ ] Syntax Decided
  - [ ] Parsing, Keyword(s), etc
  - [ ] Evaluation
- [ ] Error Handling
  - [ ] Syntax / Construct Decided
  - [ ] Parsing, Keywords(s), etc
  - [ ] Evaluation
- [ ] Type System
  - [ ] Symbol Table in Parser
  - [ ] Validate Types during parsing

## Data Types

* String
* Integer
* Float
* Boolean
* Function
* List
* Node
* Map

## Templates
Stitch supports Go templating within strings.
Such as: `{{ .Input.Key }}` to get the field name for the data provided
through the Input slot.

> **Thought**: Syntax specifically for templates?

## Variables
Variables can be defined using a `let` statement:

```
let mystr = "Hello world"
```

Variables cannot be defined without a let statement. Variables can be re-assigned using the
assignment operator (`=`).

## Comments
Comments are specified with `#` and continue until the end of the line.

## Nodes
A **Node** is a fundamental construct in stitch that provides the
basis for building flows.
Nodes form the underlying operations that a stitch can perform,
such as SNMP GET, or CLI operations.

Node implementations can be provided by a stitch,
or provided by the host application's runtime.
An example of using a node looks like:

```
# Node definition
node[Input] foo(arg) -> [Output, Errors] {
}

let f = foo("bar") # Create a new foo node
```

Each node has a set of slots that can be connected to other nodes.
Typically, nodes have an `Input`, and `Output` slot.
The `Input` slot is a standard slot for ingesting data from another node,
while the `Output` slot is the standard slot for data that is generated by
the node.

For example, a node like `snmp:get` would emit the data returned
from the SNMP Get query through the `Output` slot.

The *connect* operator (`->`) can be used to connect slots of two nodes.
Such as:

```
let a = foo("bar")
let b = foo("baz")

a.Output -> b.Input # Explicit slot connection.
a -> b              # Implicit a.Output -> b.Input
```

### Complex Configuration
The current node syntax is fine for configuring nodes with a small number
of arguments,
but there may be situations where nodes are a lot more involved to configure.
For instance,
Alert API searches may require several arguments, for filters, to be defined.

Suppose a node has the following arguments:

  * *Start DateTime* - Start of a time range
  * *End DateTime* - End of a time range
  * *Keywords* - Keywords to search for
  * *User* - User to search for

```
   let foo = search("2020-05-30T16:56:11+00:00",
                    "2020-05-30T16:56:11+00:00",
                    "foo",
                    "blah")
```

Unlike normal programming languages we can't refactor this to reduce the
number of parameters,
so it might make more sense to either provide a syntax for setting values
after node creation,
or provide the ability to use named arguments.

```
   let foo = search(start: "2020-05-30T16:56:11+00:00",
                    end: "2020-05-30T16:56:11+00:00",
                    keywords: "foo",
                    user: "blah")
```
This could also provide the ability to allow args to not be specified,
and let the node provide a default.

I think adding the ability to use named arguments,
or positional arguments would be helpful overall.

## Metadata and Fields
Data generated by a node can either be added to the metadata set, or
the set of fields for the flow.

Metadata is data that is shared between data points.
For instance, all metrics for a network device's interface `eth0` will share
the same metadata like: [`host=some.host`, `interface=eth0`].
This allows the metrics to be grouped together appropriately.

Fields are data that is generated by a node that is not shared between data
points. In the interface metrics example, these would be things like "Octets In",
or "Errors Out", for the given interface.

> Note: the following is still in design.

Stitch allows both metadata and field names to be defined any time a node is referenced.
Repeated name definitions will overwrite previous names, the configuration of the node will
retain the last field/meta name specified.
Fields and Metadata can be specified as such:

```
let fooNode = @_metadata:foo("asdf") # A foo node type created with the meta name '_metadata'
let barNode = field:foo("fdsa")      # A foo node type created with the field name 'field'
```

## Control Flow

### if..else
Stitch supports typical branching via `if` and `else` statements.

```
if y {
  # do stuff
} else if x {
  # do stuff
} else {
  # do stuff
}
```

Conditions in an `if` statement can be combined with the `and` and `or` operators.

### foreach
Originally I didn't plan on implementing loops, limiting all enumeration/iteration
behaviors to modifiers/extensions like `.foreach`, `.map`, `.filter`, `.reduce`, etc.

The reason I wanted to keep loops out, was because I didn't want to provide any
type of control structure that allowed for bugs like infinite loops, or
having to provide indexing in lists, and handling out of bounds errors, etc.

```
foreach i in list {
   println(i)
}
```

Having a foreach construct seems no different than an extension method,
and provides familiarity with some more recent programming languages.


## Extension Methods
Extension methods are like functions that can be applied to data types like Lists, Nodes, etc.
This is much like object methods, or extensions in Swift.

This is the first change to stitch that requires type information.

Common examples:

```
snmp.get("ifHCInOctets.1").delta() # Calculate the difference between successive snmp.gets

snmp.walk("ifType").filter(fn(d): d.Value == 6) # Walk an oid, but only emit values that match the lambda.
```

Syntax:

```
# Modifier for LISTS which returns the 'sum' of all values
mod sum(l: List, f) {
  l.reduce(0, fn(acc, x): acc + x)
}

# Modifier for LISTs which performs a reduce operation
mod reduce(l: List, start, f) {
  let acc = start
  l.foreach(fn(x): acc = acc + x) # foreach is a builtin modifier, as loops aren't supported.
}

let mylist = [1, 2, 3, 4]

mylist.sum() # returns 10
```

Another potential for extension methods is extending node implementations.
By providing an extension method for nodes, the extension method can be used in
place of linking to another simple node. For instance something like this would be possible:

```
mod filter(l: List, f) {
  let ret = []
  foreach i in l {
    if f(i) {
      ret = ret + [i]
    }
  }
  ret
}

# Extends any node type with an input slot named Input, and output slot named Output.
mod filter(n: node[Input] -> [Output], f) {
  Output = Input.filter(f) # assuming input/output data is a list.
}

let root = std.passthru().filter(fn(data): data.Value == 6)
```

## Batches
A **batch** is an easy way to wire to connect one slot to a collection
of other nodes'.

An example of this can be using the output of an SNMP Walk to trigger
multiple individual SNMP Gets to be performed:

```
snmp.walk("ifType") -> [
    snmp.get("ifInOctets.{{ .Input.Key.Token - 1 }}"),
    snmp.get("ifOutOctets.{{ .Input.Key.Token - 1}}")
]
```

This is functionality equivalent to:

```
let types = snmp.walk("ifType")
types.Output -> snmp.get("ifInOctets.{{ .Input.Key.Token - 1 }}")
types.Output -> snmp.get("ifOutOctets.{{ .Input.Key.Token - 1 }}")
```

## Blocks
Blocks are created via `{` and `}`, like in most brace-oriented languages.
A block can be used to execute a few statements, or organize things.
The block will evaluate to the last statement in the block.
So for instance, if you wanted to capture a node with some specific
configuration, you could do something like:

```
let mynode = {
    let tmp = snmp.get("sysDescr")
    tmp.Error -> globalErrorNode
    tmp
}
```

## Imports
Stitch files can be combined using the `import` statement.

```
import "someother.stitch"
```

Importing from another file places any macros, or variables,
into a namespace named after the file that was imported.
So the above import would be scoped to the namespace `someother`.


## Hosted Objects
The stitch host will provide a standard library
of objects which can include Functions, Node implementations,
or just objects with data.

Rather than have magic functions (usually referred to as 'builtins', that
just work), I wanted to play around with using a system similar to
C's `extern` where we can link a stitch identifier to the hosted
function in our own stitch package(s) and use them just like any
other stitch object.

The current syntax is fairly simple, but I'm not 100% happy with it:

```
let snmp_get = internal "snmp:get"   # Hosted node type
let Agent = internal "std:Agent"     # Hosted data
let println = internal "std:println" # Hosted function
```

Eventually I want to add type information to declarations,
so this would probably move more towards a prototype-like declaration
(more like `extern`)
